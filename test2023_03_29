#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <string.h>
/*
int main()
{
	//二维数组
	int a[3][4] = { 0 };
	printf("%p\n", &a[0][0]);
	printf("%p\n", &a[0][0]);
	printf("%d\n", sizeof(a));				//a这里表示的是整个数组，故是48个字节
	printf("%d\n", sizeof(a[0][0]));		//4个字节
	//a[0]可以表示第一行数组的数组名，故计算的是第一行大小
	printf("%d\n", sizeof(a[0]));			//4 * 4 = 16 个字节
	//a[0]可以表示第一行数组的数组名,也是首元素的地址，a[0] + 1是第一行第二个元素的地址
	printf("%d\n", sizeof(a[0] + 1));		//4或者8个字节
	//a[0] + 1是第一行第二个元素的地址,再解引用就是 第一行第二个元素 计算得到是4个字节
	printf("%d\n", sizeof(*(a[0] + 1)));	//（把第二行首元素传给sizeof()）这里写错了，故是4个字节
	//a+1是谁的地址？a是二维数组的数组名，没有sizeof（数组名），也没有&（数组名），所以a是首元素的地址
	//而二维数组看成一维数组时，二维数组的首元素是他的第一行，a就是第一行（首元素）的地址
	//a+1就是第二行地址
	printf("%d\n", sizeof(a + 1));			//这里表示数组地址再跳过一个数组的地址，故4或者8个字节
	//a+1就是第二行地址,再解引用就是第二行的数组，故是16个字节
	printf("%d\n", sizeof(*(a + 1)));		//4*4 = 16
	//a[0]是第一行的数组名，&a[0]是第一的地址，再加1就是第二行的地址
	printf("%d\n", sizeof(&a[0] + 1));		//4或者8个字节
	printf("%d\n", sizeof(*(&a[0] + 1)));	//第二行数组，4*4=16
	//a是第一行地址，a是首元素地址，*a就是第一行
	printf("%d\n", sizeof(*a));				//为4*4= 16 个字节
	printf("%d\n", sizeof(a[3]));			//第四行数组，因此就是 4 * 4 = 16 个字节
	return 0;
}
*/


//写代码有三种境界
//看代码是代码
//看代码是内存
//看代码是代码

/*
int main()
{
	int a[5] = { 1, 2, 3, 4, 5 };
	int* ptr = (int*)(&a + 1);
	printf("%d,%d", *(a + 1), *(ptr - 1));
	return 0;
}
*/
/*
struct Test
{
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
//假设p 的值为0x100000。 如下表表达式的值分别为多少？
//已知，结构体Test类型的变量大小是20个字节
int main()
{
	p = (struct Test*)0x100000;
	//p+1相当于跳过一个结构体
	printf("%p\n", p + 0x1);					//0x100000+0x000014
	printf("%p\n", (unsigned long)p + 0x1);		//p一开始存放的是0x100000。但是呢，经过（unsigned long）转化为整数了1,048,576，然后再加1
	printf("%p\n", (unsigned int*)p + 0x1);		//p一开始存放的是0x100000。但是呢，经过（unsigned long）转化为无符号的整型指针，加一表示加一个整型字节
	//a+1这里1加的是多少个字节取决a是什么类型
	//a+1这里1加的是多少个字节取决a是什么类型
	return 0;
}
*/
/*
int main()
{
	//假设a的地址是0x00 00 00 01
	//a的单元里放的是：01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00(小端存储)
	//
	int a[4] = { 1, 2, 3, 4 };
	int* ptr1 = (int*)(&a + 1);
	int* ptr2 = (int*)((int)a + 1);			//这里a是首元素地址，再转化为整型，再加1,（5+1=6），然后再转化为整型地址，解引用后读取的4个字节内容
	printf("%x,%x", ptr1[-1], *ptr2);		//用16进制打印
	return 0;
}
*/
/*
int main()
{
	//这里用的是逗号表达式
	int a[3][2] = { (0, 1), (2, 3), (4, 5) };
	int* p;
	p = a[0];
	printf("%d", p[0]);		//p[0] == *(p+0)
	return 0;
}
*/

//太难
int main()
{
	int a[5][5];
	int(*p)[4];
	p = a;			//int(*)[] ------ int(*)[5]
	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	return 0;
}





