#define _CRT_SECURE_NO_WARNINGS 1

#include <stdio.h>
#include <string.h>
#include <assert.h>

/*
int main()
{
	//int arr[10]={1,2,3,4,5};
	//int* p = arr;
	//*(p+2)=*(arr+2)=arr[2];这里是类比的效果
	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int* ptr1 = (int*)(&aa + 1);
	int* ptr2 = (int*)(*(aa + 1));					//*(aa+1)==aa[1]---第二行首元素地址
	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));		//10,5																								
	return 0;
}
*/
/*
int mian()
{
	char* p="abcdef";//把常量字符串的地址放到p单元里
}
*/
/*
int main()
{
	//这里有一个指针数组a,数组里的元素是指针类型，即存放的三个常量字符串的地址
	char* a[] = { "work","at","alibaba" };
	char** pa = a;		//*pa表面pa是一个指针变量，char*表面指针指向的是a的类型是char*,a是数组名，是首元素的地址
	pa++;
	printf("%s\n", *pa);
	return 0;
}*/
/*
//太难
int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRST" };
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	//后面备注结果是错的
	printf("%s\n", **++cpp);					//POINT
	printf("%s\n", *-- * ++cpp + 3);			//ENTER
	printf("%s\n", *cpp[-2] + 3);				//cpp[-2]==*(cpp-2)  NEW
	printf("%s\n", cpp[-1][-1] + 1);			//cpp[-1]==*(cpp-1);cpp[-1][-1]==*(cpp-1)[-1]==*(*(cpp-1)-1)
	return 0;
}
*/

/*
void reverse(char* str)
{
	int len = strlen(str);
	char* left = str;
	char* right = str + len - 1;
	while (left<right)
	{
		char temp = *left;
		*left = *right;
		*right = temp;
		left++;
		right--;
	}
}
int main()
{
	char arr[256] = { 0 };
	//scanf("%s", arr);
	gets(arr);//读取一行，不关注空格
	//逆序函数
	reverse(arr);
	printf("逆序后的字符串：%s\n", arr);
	return 0;
}
*/

//字符串函数使用和剖析
//size_t == unsigned int
/*
char* my_strcpy(char* dest,const char* src)
{
	assert(dest != NULL);
	assert(src != NULL);
	/*
	while (*src)
	{
		*dest++ = *src++;
	}
	*dest = *src;*/
	char* ret=dest;
	while (*dest++ = *src++)
	{
		;
	}
	//返回目的空间的起始地址
	return ret;
}
int main()
{
	//int len = strlen("abcdef");
	//printf("%d\n", len);
	char arr1[] = "abcdef";
	char arr2[] = "bit";
	//错误示范：char arr2[]={'b','i','t'};越界访问
	//错误示范：char* arr1="abcdef";p指向的是一个常量字符串，常量字符串不能被改变
	char* ret=my_strcpy(arr1, arr2);
	printf("%s\n", ret);
	return 0;
}
*/
//
//int main()
//{
//	char* p1 = "abcdef";	//长度是6
//	char* p2 = "sqwer";		//长度是5	
//	int ret=strcmp(p1, p2);
//	printf("%d\n", ret);
//	return 0;
//}

//int my_strcmp(const char* str1,const char* str2)
//{
//	assert(str1 && str2);
//	while (*str1==*str2)
//	{
//		if (*str1 == '\0')
//			return 0;	//等于0
//		str1++;
//		str2++;
//	}
//	if (*str1 > *str2)
//		return 1;		//大于
//	else if (*str1 < *str2)
//		return -1;		//小于
//}
/*
int my_strcmp(const char* str1,const char* str2)
{
	assert(str1 && str2);
	while (*str1==*str2)
	{
		if (*str1 == '\0')
			return 0;	//等于0
		str1++;
		str2++;
	}
	return (*str1 - *str2);	
}
int main()
{
	char* p1 = "abcdef";
	char* p2 = "abqwe";
	int ret = my_strcmp(p1, p2);
	printf("%d", ret);
	return 0;
}*/

int main()
{
	char arr1[5] = { "abc" };
	char arr2[] = "hello bit";
	//strcpy的脾气就是拷贝‘\0’之前的字符，不管拷贝地址能不能放下
	//一个优化的拷贝函数是strncpy，多了一个参数count
	//strcpy(arr1, arr2);		//超出了栈空间
	//printf("%s\n", arr1);		
	return 0;
}


